function e(e,s,n,t){return new(n||(n=Promise))((function(a,r){function i(e){try{d(t.next(e))}catch(e){r(e)}}function c(e){try{d(t.throw(e))}catch(e){r(e)}}function d(e){var s;e.done?a(e.value):(s=e.value,s instanceof n?s:new n((function(e){e(s)}))).then(i,c)}d((t=t.apply(e,s||[])).next())}))}function s(){return`${Date.now().toString(36)}-${Math.random().toString(36).substring(2,8)}`}class n{constructor(e,n){this.channel=e,this.proceduresImplementation=n,this.senderId=`server-${s()}`,this.channel.addMessageListener((e=>this.handleMessage(e))),this.sendServerReadyMessage()}sendServerReadyMessage(){const e=this.createMessage({id:s(),messageType:"serverReadyMessage"});this.sendMessage(e)}createMessage(e){return Object.assign(Object.assign({},e),{senderId:this.senderId})}wrapCallbackArgs(e){return e.map((e=>function(e){return"callback"===e.type&&"string"==typeof e.callbackId}(e)?(...s)=>{const n=this.createMessage({messageType:"callbackMessage",callbackId:e.callbackId,args:s,id:"noop"});this.sendMessage(n)}:e))}sendMessage(e){this.channel.sendMessage(JSON.stringify(e))}handleMessage(s){return e(this,void 0,void 0,(function*(){const e=JSON.parse(s);if(e.senderId!==this.senderId)if("clientReadyMessage"===e.messageType)this.sendServerReadyMessage();else if("invokeMessage"===e.messageType){const{id:s,procedure:n,args:t}=e,a=this.wrapCallbackArgs(t);try{const e=this.proceduresImplementation[n];if("function"!=typeof e)throw new Error(`Procedure '${n}' is not a function`);const t=yield e.bind(this.proceduresImplementation)(...a),r=this.createMessage({messageType:"resultMessage",id:s,result:t});this.sendMessage(r)}catch(e){const n=this.createMessage({messageType:"errorMessage",id:s,error:`${e}`});this.sendMessage(n)}}}))}cleanup(){this.channel.removeMessageListener(this.handleMessage)}}class t{constructor(e){this.channel=e,this._isConnected=!1,this.onConnectHandler=null,this.procedures={},this.callbacks={},this.senderId=`client-${s()}`,this.channel.addMessageListener((e=>this.handleMessage(e))),this.sendClientReadyMessage()}createMessage(e){return Object.assign(Object.assign({},e),{senderId:this.senderId})}sendClientReadyMessage(){const e=this.createMessage({id:s(),messageType:"clientReadyMessage"});this.sendMessage(e)}sendMessage(e){this.channel.sendMessage(JSON.stringify(e))}onConnect(e){this.onConnectHandler=e,this.isConnected&&e()}get isConnected(){return this._isConnected}get proxy(){return new Proxy({},{get:(e,n)=>(...e)=>{const t=s(),a=e.map(((e,s)=>{if("function"==typeof e){const n=`${t}-${s}`;return this.callbacks[n]=e,{type:"callback",callbackId:n}}return e})),r=this.createMessage({messageType:"invokeMessage",id:t,procedure:n,args:a});return this.sendMessage(r),new Promise((e=>{this.procedures[t]=e}))}})}handleMessage(e){const s=JSON.parse(e);if(s.senderId!==this.senderId)switch(s.messageType){case"serverReadyMessage":{const e=!this._isConnected;this._isConnected=!0,e&&this.onConnectHandler&&this.onConnectHandler();break}case"resultMessage":{const{id:e,result:n}=s;this.procedures[e](n),delete this.procedures[e];break}case"errorMessage":{const{id:e,error:n}=s;this.procedures[e](Promise.reject(new Error(n)));break}case"callbackMessage":{const{callbackId:e,args:n}=s;this.callbacks[e](...n);break}}}cleanup(){this.channel.removeMessageListener(this.handleMessage)}}export{t as Client,n as Server};
//# sourceMappingURL=tango-rpc.min.mjs.map
